#package syccore : exe;

#include os;
#include threading;
#include io;

#using threading;

&stdout = new os.stdout({ type: "local" });

global $string.empty : str = str(null);

macro print($x) => stdout.out(new os.buffer({ content: str(x), charset: "utf8"}));

macro println($x) => stdout.out(new os.buffer({ content: str(x) + "\n", charset: "utf8"}));

func str input($prompt : str) {
	stdout.out(new os.buffer({ content: str(x), charset: "utf8"}));
	$result = stdout.stdin(new os.buffer({charset: "utf8"}));
	return result;
}

func str join($x : list, $delimiter : str = string.empty) {
	return (yield (value : str) += lambda(x[y] => y) + delimiter).slice(-delimiter.length);
}

func slice(str, $start : int, $end : int) {
	return yield (value : str) += lambda(this[y] => y if(y < start && y > end));
}

func split(str, $delimiter : str = null) {
	$split_list = yield (value : list).append(lambda(this[y] => y));
	if(delimiter == null) {
		return split_list;
	}
	else {
		$rt_list = [];
		$current_str = string.empty;
		for($item in split_list) {
			if(item == delimiter) {
				rt_list.append(current_str);
				current_str = string.empty;
			}
			else {
				current_str += item;
			}
		}
		return rt_list;
	}
}

func append(list, $content) {
	return this + [content];
}

func concat(str, ** $strings) {
	return lambda(strings[y] => y).join();
}

func reverse(str) {
	return lambda(this[-y] => y).join();
}

func reverse(list) {
	return lambda(this[-y] => y);
}

func toUpper(str) {
	return lambda(this[y] => y >> 26 if int(bin(y)) <= 25);
}

func toUpper(char) {
	return func($x << this) {
		return lambda(x[y] => y >> 26 if int(bin(y)) <= 25)
	}
}

func toLower(str) {
	return lambda(this[y] => y << 26 if int(bin(y)) > 25);
}

func toUpper(char) {
	return func($x << this) {
		return lambda(x[y] => y << 26 if int(bin(y)) > 25)
	}
}

func bin($x) {
	return str(Thread.get_content(Thread.to_address(@x)));
}

func object DllImport($name : str) {
	$content = with(io.Open(name + ".dll").read("\b"));

}
