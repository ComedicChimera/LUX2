{
  "main": [
    "block",
    "module",
    "&"
  ],
  "func_main": [
    "return_stmt",
    "block"
  ],
  "block_main": [
    "stmt block_main",
    "BREAK ; block_main",
    "CONTINUE ; block_main",
    "sub_blocks block_main",
    "&"
  ],
  "type_main": [
    "IDENTIFIER = set_expr , type_main",
    "IDENTIFIER , type_main",
    "&"
  ],
  "struct_main": [
    "DOLLAR THIS dot_id = set_expr struct_main ,",
    "DOLLAR THIS dot_id , struct_main",
    "&"
  ],
  "interface_main": [
    "func_decl ; interface_main",
    "&"
  ],
  "module": [
    "module_decl { constructor_block main } main",
    "&"
  ],
  "module_decl": [
    "MODULE mod_type id"
  ],
  "mod_type": [
    "ACTIVE",
    "PASSIVE",
    "AWAIT"
  ],
  "block": [
    "blocks n_blocks"
  ],
  "blocks": [
    "stmt",
    "block_stmts"
  ],
  "n_blocks": [
    "blocks n_blocks",
    "&"
  ],
  "block_stmts": [
    "func_block",
    "macro_block",
    "constructor_block",
    "struct_block",
    "interface_block",
    "type_block",
    "with_block",
    "sub_blocks",
    "async_block",
    "error_block"
  ],
  "sub_blocks": [
    "if_block",
    "do_block",
    "for_block"
  ],
  "constructor_block": [
    "CONSTRUCTOR id ( func_params ) inherit { block_main }"
  ],
  "inherit": [
    ": id n_inherit",
    "&"
  ],
  "n_inherit": [
    ", id n_inherit",
    "&"
  ],
  "error_block": [
    "ERROR_HANDLER ( error_list , inline_func ) { main }"
  ],
  "error_list": [
    "obj_id n_error_list"
  ],
  "n_error_list": [
    ", obj_id n_error_list",
    "&"
  ],
  "async_block": [
    "async_decl { func_main }"
  ],
  "async_decl": [
    "ASYNC var_modifiers func_types id ( func_params )"
  ],
  "with_block": [
    "WITH ( with_expr ) { block_main }"
  ],
  "with_expr": [
    "var_decl",
    "pointer_decl",
    "set_expr"
  ],
  "struct_block": [
    "STRUCT id { struct_main }"
  ],
  "inferface_block": [
    "INTERFACE id { interface_main }"
  ],
  "type_block": [
    "TYPE id { type_main }"
  ],
  "if_block": [
    "IF ( cond_expr ) { block_main } elif_block",
    "IF ( cond_expr ) { block_main } else_block"
  ],
  "elif_block": [
    "ELIF ( cond_expr ) { block_main } elif_block",
    "ELIF ( cond_expr ) { block_main } else_block",
    "&"
  ],
  "else_block": [
    "ELSE { block_main }"
  ],
  "do_block": [
    "DO ( cond_expr ) { block_main }",
    "DO { block_main }",
    "DO { block_main } IF ( cond_expr ) ;"
  ],
  "for_block": [
    "FOR ( for_params ) { block_main }",
    "FOR ( DOLLAR IDENTIFIER IN for_iter_params ) { block_main }"
  ],
  "multi_type": [
    "( e_types n_e_types )"
  ],
  "e_types": [
    "all_types",
    "FUNC",
    "MACRO",
    "MODULE",
    "id"
  ],
  "n_e_types": [
    ", e_types n_e_types",
    "&"
  ],
  "for_iter_params": [
    "lambda_expr",
    "yield_expr",
    "comprehension_expr",
    "obj_id",
    "func_expr",
    "AWAIT async_expr",
    "async_expr"
  ],
  "for_params": [
    "DOLLAR IDENTIFIER extension = int_math_expr ; comp_expr ; for_math_expr ;",
    "int_math_expr",
    "cond_expr ; int_math_expr"
  ],
  "for_math_expr": [
    "IDENTIFIER lit_assignment_ops int_math_expr",
    "IDENTIFIER ++",
    "IDENTIFIER --",
    "IDENTIFIER **"
  ],
  "func_block": [
    "func_decl { func_main }"
  ],
  "macro_block": [
    "macro_decl { block_main }"
  ],
  "func_decl": [
    "FUNC var_modifiers func_types id ( func_params )"
  ],
  "macro_decl": [
    "MACRO var_modifiers id ( func_params )"
  ],
  "access_modifiers": [
    "PROTECTED",
    "PRIVATE",
    "&"
  ],
  "modifiers": [
    "LOCAL",
    "GLOBAL",
    "&"
  ],
  "func_types": [
    "all_types",
    "multi_type",
    "VALUE",
    "&"
  ],
  "func_params": [
    "THIS n_func_params",
    "all_types n_func_params",
    "DOLLAR IDENTIFIER extension n_func_params",
    "@ IDENTIFIER extension n_func_params",
    "&"
  ],
  "n_func_params": [
    ", DOLLAR IDENTIFIER func_extension n_func_params",
    "@ IDENTIFIER func_extension n_func_params",
    ", optional_params",
    "&"
  ],
  "optional_params": [
    "DOLLAR IDENTIFIER extension = set_expr n_optional_params",
    "** DOLLAR IDENTIFIER"
  ],
  "n_optional_params": [
    ", DOLLAR IDENTIFIER extension = set_expr n_optional_params",
    "&"
  ],
  "stmt": [
     "stmts ; nstmts"
   ],
  "stmts": [
    "expr",
    "var_decl",
    "pointer_decl",
    "assignment",
    "fwd_decl",
    "constructor_stmt",
    "DELETE this_id",
    "WITH ( with_expr )",
    "null_decl",
    "p_null_decl",
    "throw_stmt"
  ],
  "return_stmt": [
    "func_stmt n_func_stmt"
  ],
  "func_stmt": [
    "stmt",
    "RETURN set_expr",
    "YIELD RETURN set_expr",
    "&"
  ],
  "n_func_stmt": [
    "; func_stmt n_func_stmt",
    "&"
  ],
  "throw_stmt": [
    "THROW STRING_LITERAL",
    "THROW obj_id"
  ],
  "null_decl": [
    "var_modifiers DOLLAR id extension",
    "var_modifiers AMP id extension"
  ],
  "p_null_decl": [
    "var_modifiers DOLLAR id * extension"
  ],
  "fwd_decl": [
    "func_decl",
    "macro_decl",
    "async_decl"
  ],
  "constructor_stmt": [
    "CONSTRUCTOR id ( func_params ) inherit"
  ],
  "assignment": [
    "this_id list_index lit_assignment_ops set_expr"
  ],
  "pointer_decl": [
    "DOLLAR this_id * extension = pset_expr"
  ],
  "nstmts": [
    "stmts ; nstmts",
    "&"
  ],
  "var_decl": [
    "var_modifiers DOLLAR id extension = var_yield set_expr",
    "var_modifiers AMP id extension = var_yield set_expr",
    "var_modifiers DOLLAR id extension ( var_preset ) lit_assignment_ops set_expr",
    "var_modifiers AMP id extension ( var_preset ) lit_assignment_ops set_expr"
  ],
  "var_yield": [
    "YIELD",
    "&"
  ],
  "var_modifiers": [
    "access_modifiers modifiers",
    "modifiers access_modifiers",
    "&"
  ],
  "var_preset": [
    "set_expr",
    "this",
    "all_types"
  ],
  "types": [
    "INT_TYPE array_inst",
    "BOOL_TYPE array_inst",
    "STRING_TYPE array_inst",
    "FLOAT_TYPE array_inst",
    "CHAR_TYPE array_inst",
    "LIST_TYPE array_inst",
    "DICTIONARY_TYPE dict_inst"
  ],
  "dict_inst": [
    "[ types , types ]",
    "&"
  ],
  "expr": [
    "cond_expr",
    "obj_expr",
    "math_expr",
    "func_expr",
    "comprehension_expr",
    "cast_expr",
    "AWAIT async_expr",
    "async_expr"
  ],
  "index_expr": [
    "func_expr",
    "math_expr",
    "lambda_expr",
    "comprehension_expr",
    "yield_expr",
    "AWAIT async_expr"
  ],
  "array_inst": [
    "[ p_obj_id ]",
    "[ INTEGER_LITERAL ]",
    "&"
  ],
  "set_expr": [
    "expr",
    "lambda_expr",
    "yield_expr"
  ],
  "pset_expr": [
    "pointer_math"
  ],
  "yield_expr": [
    "YIELD ( VALUE extension ) lit_assignment_ops lambda_expr",
    "YIELD ( VALUE extension ) . func_expr"
  ],
  "async_expr": [
    "ASYNC ( inline_params_decl ) { func_main }"
  ],
  "cast_expr": [
    "all_types ( set_expr )",
    "VALUE ( set_expr )"
  ],
  "lambda_expr": [
    "LAMBDA ( IDENTIFIER => expr lambda_condition)"
  ],
  "lambda_condition": [
    "IF ( cond_expr )",
    "&"
  ],
  "comprehension_expr": [
    "[ obj_id ^ ( lambda_comprehension ) ]"
  ],
  "lambda_comprehension": [
    "IDENTIFIER => expr"
  ],
  "obj_expr": [
    "NEW id ( constructor_params )"
  ],
  "constructor_params": [
    "{ named_params }"
  ],
  "named_params": [
    "IDENTIFIER : set_expr n_nmd_params"
  ],
  "n_nmd_params": [
    ", IDENTIFIER : set_expr",
    "&"
  ],
  "cond_expr": [
    "xor_op OR xor_op",
    "xor_op"
  ],
  "xor_op": [
    "and_op XOR and_op",
    "and_op"
  ],
  "and_op": [
    "not_op AND not_op",
    "not_op"
  ],
  "not_op": [
    "! comp_expr",
    "comp_expr"
  ],
  "comp_expr": [
    "bool_expr == no_math_comp_expr",
    "bool_expr != no_math_comp_expr",
    "bool_expr === no_math_comp_expr",
    "bool_expr !== no_math_comp_expr",
    "math_expr == comp_expr",
    "math_expr != comp_expr",
    "math_expr === comp_expr",
    "math_expr !== comp_expr",
    "int_math_expr > comp_expr",
    "int_math_expr < comp_expr",
    "int_math_expr >= comp_expr",
    "int_math_expr <= comp_expr",
    "math_expr",
    "BOOL_LITERAL",
    "( comp_expr )"
  ],
  "no_math_comp_expr": [
    "bool_expr == no_math_comp_expr",
    "bool_expr != no_math_comp_expr",
    "bool_expr === no_math_comp_expr",
    "bool_expr !== no_math_comp_expr",
    "math_expr == comp_expr",
    "math_expr != comp_expr",
    "math_expr === comp_expr",
    "math_expr !== comp_expr",
    "int_math_expr > comp_expr",
    "int_math_expr < comp_expr",
    "int_math_expr >= comp_expr",
    "int_math_expr <= comp_expr",
    "BOOL_LITERAL",
    "( no_math_comp_expr )"
  ],
  "bool_expr": [
    "BOOL_LITERAL",
    "math_expr"
  ],
  "math_expr": [
    "str_math_expr",
    "int_math_expr",
    "list_math_expr"
  ],
  "str_math_expr": [
    "str_mul str_add"
  ],
  "str_add": [
    "+ str_mul_expr str_add",
    "&"
  ],
  "str_mul_expr": [
    "str_types str_mul"
  ],
  "str_mul": [
    "* str_types str_mul",
    "&"
  ],
  "str_types": [
    "CHAR_LITERAL",
    "STRING_LITERAL",
    "obj_id",
    "func_expr",
    "null_id",
    "( str_math_exprs )"
  ],
  "list_math_expr": [
    "list_types list_add"
  ],
  "list_add": [
    "+ list_types list_add",
    "&"
  ],
  "list_types": [
    "list",
    "dict",
    "obj_id",
    "func_expr",
    "comprehension_expr",
    "( list_math_expr )"
  ],
  "int_math_expr": [
    "int_mul int_add"
  ],
  "int_add": [
    "+ int_mul int_add",
    "- int_mul int_add",
    "&"
  ],
  "int_mul": [
    "int_exp int_mul_ops"
  ],
  "int_mul_ops": [
    "* int_exp int_mul_ops",
    "/ int_expr int_mul_ops",
    "% int_expr int_mul_ops",
    "&"
  ],
  "int_exp": [
    "int_increm int_exp_ops"
  ],
  "int_exp_ops": [
    "^ int_exp_ops",
    "int_increm",
    "&"
  ],
  "int_increm": [
    "int_types ++",
    "int_types --",
    "int_types **",
    "( - int_types ) ++",
    "( - int_types ) --",
    "( - int_types ) **",
    "int_types"
  ],
  "int_types": [
    "FLOAT_LITERAL",
    "INTEGER_LITERAL",
    "- int_types",
    "obj_id",
    "null_id",
    "func_expr",
    "cast_expr",
    "( int_math_expr )"
  ],
  "pointer_math": [
    "( p_bin_shift ) ++",
    "( p_bin_shift ) --",
    "p_bin_shift"
  ],
  "p_bin_shift": [
    "pointer sp_bin_shift"
  ],
  "sp_bin_shift":[
    "shifts pointer np_bin_shift"
  ],
  "np_bin_shift": [
    "shifts pointer np_bin_shift",
    "&"
  ],
  "shifts": [
    "<<",
    ">>"
  ],
  "pointer": [
    "@ p_obj_id"
  ],
  "p_obj_id": [
    "obj_expr . IDENTIFIER dot_id",
    "this_id",
    "func_expr"
  ],
  "func_expr": [
    "func_call",
    "inline_func"
  ],
  "func_call": [
    "obj_id ( func_params ) dotid"
  ],
  "inline_func": [
    "FUNC ( inline_params_decl ) { func_main } dotid"
  ],
  "inline_params_decl": [
    "inline_param, n_inline_param"
  ],
  "inline_param": [
    "DOLLAR IDENTIFIER func << expr"
  ],
  "n_inline_param": [
    ", inline_param n_inline_param",
    "&"
  ],
  "lit_assignment_ops": [
    "+=",
    "-=",
    "*=",
    "/=",
    "%=",
    "^=",
    "="
  ],
  "obj_id": [
    "this_id",
    "obj_expr dotid"
  ],
  "id": [
    "IDENTIFIER list_index dotid"
  ],
  "null_id": [
    "id",
    "NULL"
  ],
  "this_id": [
    "IDENTIFIER list_index dotid",
    "THIS dotid"
  ],
  "dotid": [
    ". IDENTIFIER list_index dotid",
    "&"
  ],
  "list_index": [
    "[ obj_id ] list_index",
    "[ index_expr ] list_index",
    "&"
  ],
  "list": [
    "[ expr follow_list_item ]"
  ],
  "follow_list_item": [
    ", expr follow_list_item",
    "&"
  ],
  "dict": [
    "{ all_types : expr follow_dict_item }"
  ],
  "follow_dict_item": [
    ", all_types : expr follow_dict_item",
    "&"
  ],
  "extension": [
    ": types",
    ": FUNC",
    ": id",
    ": MACRO",
    ": MODULE",
    "multi_type",
    "&"
  ],
  "all_types" : [
    "INTEGER_TYPE",
    "FLOAT_TYPE",
    "STRING_TYPE",
    "CHAR_TYPE",
    "BOOL_TYPE",
    "LIST_TYPE",
    "DICTIONARY_TYPE",
    "deref_op all_types"
  ],
  "deref_op": [
    "* deref_op",
    "&"
  ]
}
